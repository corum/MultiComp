                        ; Tom Pittman's 6800 tiny BASIC
                        ; reverse analyzed from (buggy) hexdump (TB68R1.tiff and TB68R2.tiff) at 
                        ; http://www.ittybittycomputers.com/IttyBitty/TinyBasic/
                        ; http://www.ittybittycomputers.com/IttyBitty/TinyBasic/index.htm
                        ; http://www.ittybittycomputers.com/IttyBitty/TinyBasic/DDJ1/Design.html
                        ; by Holger Veit
                        ; http://www.ittybittycomputers.com/IttyBitty/TinyBasic/TB_6800.asm
                        ; 
                        ; Note this might look like valid assembler, but possibly isn't
                        ; for reference only
                        ;
                        ; DGG - Noted my changes with my initials
                        ; Assemble using a68
                        ;	a68 TB_6800.ASM -l TB_6800.LST -s TB_6800.s
                        ;	(From: http://www.retrotechnology.com/restore/a68.html)
                        ; Load via DGG_MIKBUG with
                        ; &
                        ; Then copy/paste into terminal window
                        
   fc18                 ACIACS	EQU	$FC18
   fc19                 ACIADA	EQU	$FC19
                        
                        ; These addresses are manually copied from MIKBUG (DGG_MIKBUG.ASM)
   f1f3                 INEEE		EQU	$f1f3
   f20a                 OUTEEE		EQU	$f20a
                        
   0000                                 org    0
   0000                                 rmb    32
   0020                 start_prgm:     rmb    2            ; $20 - start of BASIC text (0x900)
   0022                 end_ram:        rmb    2            ; $22 - end of available RAM
   0024                 end_prgm:       rmb    2            ; $24 - end of BASIC text
   0026                 top_of_stack:   rmb    2            ; $26 - top of return stack pointer location
   0028                 basic_lineno:   rmb    2            ; $28 - save for current line number to be executed
   002a                 il_pc:          rmb    2            ; $2A - program counter for IL code
   002c                 basic_ptr:      rmb    2            ; $2C - pointer to currently executed BASIC byte
   002e                 basicptr_save:  rmb    2            ; $2E temporary save for basic_ptr
   0030                 expr_stack:     rmb    80           ; $30 - lowest byte of expr_stack (0x30)
   0080                 rnd_seed:       rmb    2            ; $80 used as seed value for RND function
                                                            ; note this is actually top of predecrementing expr_stack
   0082                 var_tbl:        rmb    52           ; $82 variables (A-Z), 26 words
   00b6                 LS_end:         rmb    2            ; $B6 - used to store addr of end of LS listing,
                                                            ; start of list is in basic_ptr
   00b8                 BP_save:        rmb    2            ; $B8 another temporary save for basic_ptr
   00ba                 X_save:         rmb    2            ; $BA - temporary save for X
   00bc                 IL_temp:        rmb    2            ; $BC - temporary for various IL operations
                                                            ; used for branch to IL handler routine for opcode
   00be                 lead_zero:      rmb    1            ; $BE - flag for number output and negative sign in DV
   00bf                 column_cnt:     rmb    1            ; $BF counter for output columns (required for TAB in PRINT)
                                                            ; if bit 7 is set, suppress output (XOFF)
   00c0                 run_mode:       rmb    1            ; $C0 run mode
                                                            ; = 0 direct mode
                                                            ; <> 0 running program
   00c1                 expr_stack_low: rmb    1            ; $C1 - low addr byte of expr_stack (should be 0x30)
   00c2                 expr_stack_x:   rmb    1            ; $C2 high byte of expr_stack_top (==0x00, used with X register)
   00c3                 expr_stack_top: rmb    1            ; $C3 - low byte of expr_stack_top (used in 8 bit comparisons)
   00c4                 il_pc_save:     rmb    2            ; $C4 save of IL program counter
   00c6                                 rmb    58           ; $C6 - unused area in zero page (starting with 0xc6)
                        
                        ; cold start vector
                        ; DGG - PROGRAM START HERE
   0100                                 org    $0100
                        
   0100   bd 02 00      CV:             jsr    COLD_S       ; Do cold start initialization
                        
                        ; warm start vector
   0103   7e 02 1d      WV:             jmp    WARM_S       ; do warm start
                        
                        ; vector: get a character from input device into A
                        ; DGG - Calls MIKBUG input (INEEE)
   0106   7e f1 f3      IN_V:           jmp    INEEE
                        
                        ; print a character in A to output device
                        ; DGG - Calls MIKBUG output (OUTEEE)
   0109   7e f2 0a      OUT_V:          jmp    OUTEEE
                        
                        ; test for break from input device, set C=1 if break
                        ; unimplemented - jump to break routine
                        ; note: at the end of the program, there are two
                        ; sample implementations for MIKBUG and MINIBUG
   010c   01            BV:             nop
   010d   0c                            clc
   010e   39                            rts
                        
                        ; some standard constants
   010f   5f            BSC:            fcb    $5F          ; backspace code (should be 0x7f, but actually is '_')
   0110   18            LSC:            fcb    $18          ; line cancel code (CTRL-X)
   0111   00            PCC:            fcb    $00          ; CRLF padding characters
                        									; DGG - Used with slow teletypes - no need with VDU (was $83)
                                                            ; low 7 bits are number of NUL/0xFF
                        									; bit7=1: send 0xFF, =0, send NUL
   0112   80            TMC:            fcb    $80          ; DGG - XON/XOFF code
   0113   20            SSS:            fcb    $20          ; reserved bytes at end_prgm (to prevent return stack
                                                            ; underflow (spare area)
                        
                        ;******************************************************************************
                        ; utility routines for BASIC (not called in interpreter code)
                        ;******************************************************************************
                        
                        ;------------------------------------------------------------------------------
                        ; get the byte pointed to by X into B:A
                        ;------------------------------------------------------------------------------
   0114   a6 00         peek:           ldaa   0,x
   0116   5f                            clrb
   0117   39                            rts
                        
                        ;------------------------------------------------------------------------------
                        ; put the byte in A into cell pointed to by X
                        ;------------------------------------------------------------------------------
   0118   a7 00         poke:           staa   0,x
   011a   39                            rts
                        
                        ;******************************************************************************
                        ; Interpreter jump table
                        ;******************************************************************************
   011b                 il_jumptable:
   011b   02 90                        fdb     IL_BBR       ; 0x40-0x5f: backward branch
   011d   02 93                        fdb     IL_FBR       ; 0x60-0x7f: forward_branch
   011f   02 e6                        fdb     IL_BC        ; 0x80-0x9f: string match branch
   0121   03 0a                        fdb     IL_BV        ; 0xa0-0xbf: branch if not variable
   0123   03 33                        fdb     IL_BN        ; 0xc0-0xdf: branch if not number
   0125   03 03                        fdb     IL_BE        ; 0xe0-0xff: branch if not eoln
   0127   01 fc                        fdb     IL_NO        ; 0x08:      no operation
   0129   01 d7                        fdb     IL_LB        ; 0x09:      push literal byte to TOS
   012b   01 db                        fdb     IL_LN        ; 0x0a:      push literal word to TOS
   012d   01 89                        fdb     IL_DS        ; 0x0b:      duplicate stack top
   012f   01 a6                        fdb     IL_SP        ; 0x0c:      pop TOS into A:B
   0131   01 a9                        fdb     expr_pop_byte ; 0x0d:     undocumented: pop byte into
   0133   01 77                        fdb     sub_177      ; 0x0e:      undocumented: push TOS on return stack
   0135   01 80                        fdb     sub_180      ; 0x0f:      undocumented: pop return stack into TOS
   0137   04 a3                        fdb     IL_SB        ; 0x10:      save BASIC pointer
   0139   04 a8                        fdb     IL_RB        ; 0x11:      restore BASIC pointer
   013b   03 f8                        fdb     IL_FV        ; 0x12:      fetch variable
   013d   04 08                        fdb     IL_SV        ; 0x13:      store variable
   013f   04 c6                        fdb     IL_GS        ; 0x14:      save GOSUB line
   0141   04 91                        fdb     IL_RS        ; 0x15:      restore saved line
   0143   04 86                        fdb     IL_GO        ; 0x16:      goto
   0145   03 ba                        fdb     IL_NE        ; 0x17:      negate
   0147   03 c7                        fdb     IL_AD        ; 0x18:      add
   0149   03 c5                        fdb     IL_SU        ; 0x19:      subtract
   014b   03 dd                        fdb     IL_MP        ; 0x1a:      multiply
   014d   03 63                        fdb     IL_DV        ; 0x1b:      divide
   014f   04 1b                        fdb     IL_CP        ; 0x1c:      compare
   0151   04 41                        fdb     IL_NX        ; 0x1d:      next BASIC statement
   0153   01 fc                        fdb     IL_NO        ; 0x1e:      reserved
   0155   05 cf                        fdb     IL_LS        ; 0x1f:      list program
   0157   05 3d                        fdb     IL_PN        ; 0x20:      print number
   0159   05 b2                        fdb     IL_PQ        ; 0x21:      print BASIC string
   015b   05 ba                        fdb     IL_PT        ; 0x22:      print tab
   015d   06 20                        fdb     IL_NL        ; 0x23:      new line
   015f   05 a5                        fdb     IL_PC        ; 0x24:      print literal string
   0161   05 c3                        fdb     pt_print_spc ; 0x25:      undocumented op for SPC(x) function
   0163   01 fc                        fdb     IL_NO        ; 0x26:      reserved
   0165   06 52                        fdb     IL_GL        ; 0x27:      get input line
   0167   01 fc                        fdb     IL_NO        ; 0x28:      reserved
   0169   01 fc                        fdb     IL_NO        ; 0x29:      reserved
   016b   06 aa                        fdb     IL_IL        ; 0x2A:      Insert BASIC line
   016d   02 0a                        fdb     IL_MT        ; 0x2B:      mark BASIC program space empty
   016f   04 76                        fdb     IL_XQ        ; 0x2C:      execute
   0171   02 1d                        fdb     WARM_S       ; 0x2D:      warm start
   0173   01 b9                        fdb     IL_US        ; 0x2E:      machine language subroutine call
   0175   04 9e                        fdb     IL_RT        ; 0x2F:      IL subroutine return
                        
                        ;------------------------------------------------------------------------------
                        ; undocumented IL instruction (unused)
                        ; will take a value from expression stack
                        ; and put onto processor stack
                        ;------------------------------------------------------------------------------
   0177   8d 2d         sub_177:       bsr     IL_SP        ; pop word into A:B
   0179   97 bc                        staa    IL_temp      ; save into IL_temp
   017b   d7 bd                        stab    IL_temp+1
   017d   7e 04 cf                     jmp     push_payload ; push value on return stack
                        
                        ;------------------------------------------------------------------------------
                        ; undocumented IL instruction
                        ; will extract stored value on processor stack
                        ; and push back on expr_stack
                        ;------------------------------------------------------------------------------
   0180   bd 04 f4      sub_180:       jsr     get_payload  ; extract stored value on return stack
   0183   96 bc                        ldaa    IL_temp      ; get this value
   0185   d6 bd                        ldab    IL_temp+1
   0187   20 04                        bra     expr_push_word ; push on expr_stack
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: duplicate top    of expr_stack
                        ;------------------------------------------------------------------------------
   0189   8d 1b         IL_DS:         bsr    IL_SP         ; pop top of expr_stack into A:B
   018b   8d 00                        bsr    *+2           ; push A:B twice on expr_stack
                                                            ; (fall through to expr_push_word routine)
                        
                        ;------------------------------------------------------------------------------
                        ; push A:B on expr_stack
                        ;------------------------------------------------------------------------------
   018d   de c2         expr_push_word: ldx    expr_stack_x ; get expr_stack top
   018f   09                           dex                  ; make space for another byte
   0190   e7 00                        stab    0,x          ; store byte (low)
   0192   20 02                        bra     expr_push_a  ; push A byte
                        
                        ;------------------------------------------------------------------------------
                        ; push A on expr_stack
                        ;------------------------------------------------------------------------------
   0194   de c2         expr_push_byte: ldx    expr_stack_x ; get expr_stack top
                        
   0196   09            expr_push_a:   dex                  ; make space for another byte
   0197   a7 00                        staa    0,x          ; save A as new TOS (top of stack value)
   0199   df c2                        stx     expr_stack_x ; set new stack top
   019b   36                           psha                 ; save A
   019c   96 c1                        ldaa    expr_stack_low ; get stack bottom
   019e   91 c3                        cmpa    expr_stack_top ; stack overflow?
   01a0   32                           pula                 ; restore A
   01a1   25 59                        bcs     IL_NO        ; no, exit
                        
   01a3   7e 02 54      j_error:       jmp     error        ; error: stack overflow
                        
                        ;------------------------------------------------------------------------------
                        ; pop the TOS word off stack, result in A:B
                        ;------------------------------------------------------------------------------
   01a6   8d 01         IL_SP:         bsr     expr_pop_byte ; pop a byte into B
   01a8   17                           tba                  ; put into A (high byte)
                                                            ; fall thru to expr_pop_byte to get more
                        
                        ;------------------------------------------------------------------------------
                        ; pop the TOS byte off stack into B
                        ;------------------------------------------------------------------------------
   01a9   c6 01         expr_pop_byte: ldab    #1           ; verify stack is not empty: has 1 byte
                        
   01ab   db c3         pop_byte:      addb    expr_stack_top ; next position on stack
   01ad   c1 80                        cmpb    #$80         ; is it > 0x80?
   01af   22 f2                        bhi     j_error      ; yes, stack underflow error
   01b1   de c2                        ldx     expr_stack_x ; get address of stack top
   01b3   7c 00 c3                     inc     expr_stack_top  ; pop stack
   01b6   e6 00                        ldab    0,x          ; get TOS byte in B
   01b8   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction US: machine language subroutine call
                        ;------------------------------------------------------------------------------
   01b9   8d 05         IL_US:         bsr     us_do        ; call machine language routine
   01bb   8d d7                        bsr     expr_push_byte ; return here when ML routine does RTS
                                                            ; push A:B on stack
   01bd   17                           tba
   01be   20 d4                        bra     expr_push_byte
                        
   01c0   86 06         us_do:         ldaa    #6           ; verify that stack has at least 6 bytes
   01c2   16                           tab
   01c3   9b c3                        adda    expr_stack_top
   01c5   81 80                        cmpa    #rnd_seed    ; at end of expr_stack?
   01c7   22 da                        bhi     j_error      ; yes, error
   01c9   de c2                        ldx     expr_stack_x ; load argument list
   01cb   97 c3                        staa    expr_stack_top ; drop 6 bytes from stack
                        
   01cd   a6 05         us_copyargs:   ldaa    5,x          ; push 5 bytes to return stack
   01cf   36                           psha
   01d0   09                           dex
   01d1   5a                           decb
   01d2   26 f9                        bne     us_copyargs  ; loop until done
   01d4   07                           tpa                  ; push status
   01d5   36                           psha
                                       ; Stack frame is
                                       ; return address IL_US+2 (caller of bsr us_do)
                                       ; B
                                       ; A
                                       ; X
                                       ; X
                                       ; address
                                       ; address
                                       ; PSW
   01d6   3b                           rti                  ; use RTI to branch to routine
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction push byte
                        ;------------------------------------------------------------------------------
   01d7   8d 1c         IL_LB:         bsr     fetch_il_op  ; get next byte from sequence
   01d9   20 b9                        bra     expr_push_byte  ; push single byte
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction push word
                        ;------------------------------------------------------------------------------
   01db   8d 18         IL_LN:         bsr     fetch_il_op  ; get next two bytes into A:B
   01dd   36                           psha
   01de   8d 15                        bsr     fetch_il_op
   01e0   16                           tab
   01e1   32                           pula
   01e2   20 a9                        bra     expr_push_word ; push on stack
                        
                        ;------------------------------------------------------------------------------
                        ; part of IL linterpreter loop, handle SX instruction
                        ;------------------------------------------------------------------------------
   01e4   9b c3         handle_il_SX:  adda    expr_stack_top ; opcode is 0..7, add to current stack ptr
   01e6   97 bd                        staa    IL_temp+1      ; make word pointer 0x00SP+opcode
   01e8   7f 00 bc                     clr     IL_temp
   01eb   8d bc                        bsr     expr_pop_byte  ; drop to byte into B
   01ed   de bc                        ldx     IL_temp        ; get index
   01ef   a6 00                        ldaa    0,x            ; get old byte
   01f1   e7 00                        stab    0,x            ; store byte from TOS there
   01f3   20 9f                        bra     expr_push_byte ; store old byte on TOS
                        
                        ;------------------------------------------------------------------------------
                        ; get the next IL opcode and increment the IL PC
                        ;------------------------------------------------------------------------------
   01f5   de 2a         fetch_il_op:   ldx     il_pc        ; get IL PC
   01f7   a6 00                        ldaa    0,x          ; read next opcode
   01f9   08                           inx                  ; advance to next byte
   01fa   df 2a                        stx     il_pc        ; save IL PC
                        
   01fc   4d            IL_NO:         tsta                 ; set flags
   01fd   39                           rts
                        
                        ;------------------------------------------------------------------------------
   01fe   07 9a         IL_baseaddr:   fdb start_of_il      ; only used address where IL code starts
                        
                        ;------------------------------------------------------------------------------
                        ; Cold start entry point
                        ;------------------------------------------------------------------------------
   0200   ce 09 00      COLD_S:        ldx     #$0900		; DGG - initialize start of BASIC
   0203   df 20                        stx     start_prgm
                        
                        ; DGG - Original routine will over-write MIKBUG scratch-pad area when testing SRAM
   0205                 find_end_ram:
                        			; inx                  ; point to next address
                                    ; com     1,x          ; complement following byte
                                    ; ldaa    1,x          ; load byte
                                    ; com     1,x          ; complement byte
                                    ; cmpa    1,x          ; compare with value, should be different, if it is RAM
                                    ; bne     find_end_ram ; if different, advance, until no more RAM cells found
   0205   ce ee ff      			ldx     #$EEFF		   ; Hard coded to 60KB minus 128-byte scratechpad space
   0208   df 22                     stx     end_ram        ; use topmost RAM cell
                        			
                        ;------------------------------------------------------------------------------
                        ; IL instruction MT: clear program space
                        ;------------------------------------------------------------------------------
   020a   96 20         IL_MT:         ldaa    start_prgm   ; load start area
   020c   d6 21                        ldab    start_prgm+1
   020e   fb 01 13                     addb    SSS          ; add spare area after end of program
   0211   89 00                        adca    #0
   0213   97 24                        staa    end_prgm     ; save as end of program
   0215   d7 25                        stab    end_prgm+1
   0217   de 20                        ldx     start_prgm   ; get addr of start of program
   0219   6f 00                        clr     0,x          ; clear line number (means end)
   021b   6f 01                        clr     1,x
                        
                        ;------------------------------------------------------------------------------
                        ; warm start entry point
                        ;------------------------------------------------------------------------------
   021d   9e 22         WARM_S:        lds     end_ram      ; set return stack to end of RAM
                        
                                       ; enters here to start IL loop;
                        			   ; return here after error stop
   021f   bd 06 24      restart_il:    jsr     crlf         ; emit a CRLF
                        
   0222   fe 01 fe      restart_il_nocr: ldx   IL_baseaddr  ; load pointer to IL
   0225   df 2a                        stx     il_pc        ; store as current IL PC
   0227   ce 00 80                     ldx     #rnd_seed    ; set expr_stack top to 0x0080
   022a   df c2                        stx     expr_stack_x
   022c   ce 00 30                     ldx     #$30         ; set run_mode = 0 (no program)
                                                            ; set expr_stack_low = 0x30
   022f   df c0                        stx     run_mode
                        
   0231   9f 26         il_rs_return:  sts     top_of_stack ; save current stack position
                        
   0233   8d c0         il_mainloop:   bsr     fetch_il_op  ; fetch next IL opcode
   0235   8d 07                        bsr     exec_il_opcode ; execute current IL instruction
   0237   20 fa                        bra     il_mainloop  ; next instruction
                        
                                       ; trick programming here:
                                       ; this location is entered in IL_RS
                                       ; by incrementing the return address of exec_il_opcode
                                       ; so that it skips over the 'BRA il_mainloop' above
   0239   8c 20 04      il_rs_target:  cpx     #$2004       ; this might mask a BRA *+4, which however would
                                                            ; then point into exec_il_opcode+2, which is a TBA
                                                            ; which could then be used for a synthetic 
                        									; exec_il_opcode...
                                                            ; frankly: this is possibly either a remainder
                                                            ; from old code or a hidden serial number
                        									; the 6502 code has a similar anachronism in this
                        									; place, so it might be a serial number.
   023c   20 f3                        bra     il_rs_return ; enforce storing the stack pointer and do il_mainloop
                        
                        ;------------------------------------------------------------------------------
                        ; with IL opcode in A, decode opcode and
                        ; branch to appropriate routine
                        ;------------------------------------------------------------------------------
   023e   ce 01 17      exec_il_opcode: ldx    #il_jumptable-4 ; preload address of opcode table - 4
   0241   df bc                        stx     IL_temp
   0243   81 30                        cmpa    #$30         ; is opcode below 0x30?
   0245   24 56                        bcc     handle_30_ff ; no, skip to handler for higher opcodes
   0247   81 08                        cmpa    #8           ; is it below 8?
   0249   25 99                        bcs     handle_il_SX ; yes, skip to handler for SX instructions
   024b   48                           asla                 ; make word index
   024c   97 bd                        staa    IL_temp+1    ; store as offset
   024e   de bc                        ldx     IL_temp
   0250   ee 17                        ldx     $17,x        ; load handler address via offset
   0252   6e 00                        jmp     0,x          ; jump to handler
                        
                        ;------------------------------------------------------------------------------
                        ; common error routine
                        ;------------------------------------------------------------------------------
   0254   bd 06 24      error:         jsr     crlf         ; emit CRLF
   0257   86 21                        ldaa    #'!'
   0259   97 c1                        staa    expr_stack_low ; lower stack bottom a bit to avoid another stack fault
                                                            ; SNAFU already; may overwrite some variables
   025b   bd 01 09                     jsr     OUT_V        ; emit exclamation mark
   025e   86 80                        ldaa    #rnd_seed    ; reinitialize stack top
   0260   97 c3                        staa    expr_stack_top
   0262   d6 2b                        ldab    il_pc+1      ; load IL PC into A:B
   0264   96 2a                        ldaa    il_pc
   0266   f0 01 ff                     subb    IL_baseaddr+1 ; subtract origin of interpreter
   0269   b2 01 fe                     sbca    IL_baseaddr
   026c   bd 05 3a                     jsr     emit_number  ; print instruction of IL
   026f   96 c0                        ldaa    run_mode     ; is not in program?
   0271   27 0f                        beq     error_no_lineno ; no, suppress output of line number
   0273   ce 02 8b                     ldx     #err_at      ; load error string
   0276   df 2a                        stx     il_pc
   0278   bd 05 a5                     jsr     IL_PC        ; print string at il_prgm_cnt, i.e. "AT "
   027b   96 28                        ldaa    basic_lineno ; get line number
   027d   d6 29                        ldab    basic_lineno+1
   027f   bd 05 3a                     jsr     emit_number  ; print it
                        
   0282   86 07         error_no_lineno: ldaa  #7           ; emit BEL (0x07) character
   0284   bd 01 09                     jsr     OUT_V
   0287   9e 26                        lds     top_of_stack ; restore return stack
   0289   20 94                        bra     restart_il   ; restart interpreter after error
                        
   028b   20 41 54 20   err_at:        fcb     ' ','A','T',' ',$80 ; string " AT " + terminator
   028f   80            
                        
                        ;------------------------------------------------------------------------------
                        ; long branch instruction
                        ;------------------------------------------------------------------------------
   0290   7a 00 bc      IL_BBR:        dec     IL_temp      ; adjust position for negative jump (effectively 2's complement)
                        
   0293   7d 00 bc      IL_FBR:        tst     IL_temp      ; test new position high byte
   0296   27 bc                        beq     error        ; was displacement 0?
                                                            ; yes, this is an error condition
                        
   0298   de bc         il_goto:       ldx     IL_temp      ; get new IL target address
   029a   df 2a                        stx     il_pc        ; do the jump
   029c   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; part of interpreter loop: handle opcode 0x30-3f
                        ;------------------------------------------------------------------------------
   029d   81 40         handle_30_ff:  cmpa    #$40         ; above or equal 0x40?
   029f   24 23                        bcc     handle_40_ff ; yes, handle elsewhere
                        
                                       ; handle the J/JS instructions
   02a1   36                           psha                 ; save opcode
   02a2   bd 01 f5                     jsr     fetch_il_op  ; get next byte of instruction (low address)
   02a5   bb 01 ff                     adda    IL_baseaddr+1 ; add to IL interpreter base
   02a8   97 bd                        staa    IL_temp+1
   02aa   32                           pula                 ; restore opcode
   02ab   16                           tab                  ; save into B for later
   02ac   84 07                        anda    #7           ; mask out addressbits
   02ae   b9 01 fe                     adca    IL_baseaddr  ; add to base address
   02b1   97 bc                        staa    IL_temp      ; save in temporary
   02b3   c4 08                        andb    #8           ; mask J/JS bit
   02b5   26 e1                        bne     il_goto      ; if set, is GOTO
   02b7   de 2a                        ldx     il_pc        ; get current IL PC
   02b9   97 2a                        staa    il_pc        ; save new IL PC
   02bb   d6 bd                        ldab    IL_temp+1
   02bd   d7 2b                        stab    il_pc+1
   02bf   df bc                        stx     IL_temp      ; save old in temporary
   02c1   7e 04 cf                     jmp     push_payload ; put on return stack
                        
                        ;------------------------------------------------------------------------------
                        ; handle the opcodes >=0x40
                        ;------------------------------------------------------------------------------
   02c4   16            handle_40_ff:  tab                  ; save opcode for later
   02c5   44                           lsra                 ; get opcode high nibble
   02c6   44                           lsra
   02c7   44                           lsra
   02c8   44                           lsra
   02c9   84 0e                        anda    #$E          ; make 0x04,0x06,...0x0e
   02cb   97 bd                        staa    IL_temp+1    ; make index into opcode jump table
   02cd   de bc                        ldx     IL_temp
   02cf   ee 17                        ldx     $17,x        ; X points to handler routine
   02d1   4f                           clra                 ; preload A=0 for null displacement (error indicator)
   02d2   c1 60                        cmpb    #$60         ; is it BBR?
   02d4   c4 1f                        andb    #$1F         ; mask out displacement bits
   02d6   24 02                        bcc     not_bbr      ; was not backward branch
   02d8   ca e0                        orab    #$E0         ; make displacement negative
                        
   02da   27 06         not_bbr:       beq     displ_error  ; displacement is zero? yes, skip
   02dc   db 2b                        addb    il_pc+1      ; add displayement to current IL_PC
   02de   d7 bd                        stab    IL_temp+1
   02e0   99 2a                        adca    il_pc
                        
   02e2   97 bc         displ_error:   staa    IL_temp      ; store high byte of new address
                                                            ; if displayement=0, store high byte=0
                                                            ; -> invalid IL address, will lead to error
   02e4   6e 00                        jmp     0,x          ; jump to handler routine
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction string match branch
                        ; jump forward if string was not matched
                        ;------------------------------------------------------------------------------
   02e6   de 2c         IL_BC:         ldx     basic_ptr    ; save pointer to current BASIC character
   02e8   df b8                        stx     BP_save
                        
   02ea   8d 36         bc_loop:       bsr     get_nchar    ; skip spaces
   02ec   8d 2a                        bsr     fetch_basicchar ; consume char
   02ee   16                           tab                  ; save into B
   02ef   bd 01 f5                     jsr     fetch_il_op  ; get next char from IL stream
   02f2   2a 02                        bpl     bc_lastchar  ; if positive (not end of string), match further
   02f4   ca 80                        orab    #$80         ; no, make basic char also bit7 set
                        
   02f6   11            bc_lastchar:   cba                  ; compare bytes
   02f7   26 04                        bne     bc_nomatch   ; do not match, skip
   02f9   4d                           tsta                 ; more chars to match?
   02fa   2a ee                        bpl     bc_loop      ; yes, loop
   02fc   39                           rts                  ; that string matched! continue
                        
   02fd   de b8         bc_nomatch:    ldx     BP_save      ; restore BASIC pointer
   02ff   df 2c                        stx     basic_ptr
                        
   0301   20 90         j_FBR:         bra     IL_FBR       ; and branch forward
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: jump if not end of line
                        ;------------------------------------------------------------------------------
   0303   8d 1d         IL_BE:         bsr     get_nchar    ; get current BASIC char
   0305   81 0d                        cmpa    #$D          ; is it a CR?
   0307   26 f8                        bne     j_FBR        ; no, jump forward
   0309   39                           rts                  ; continue
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: branch if not variable
                        ; if variable, push 2*ASCII to expr_stack
                        ; (0x41..0x5A => 0x82...0xB4
                        ;  == offset to var table into zero page)
                        ;------------------------------------------------------------------------------
   030a   8d 16         IL_BV:         bsr     get_nchar    ; get current BASIC char
   030c   81 5a                        cmpa    #'Z'         ; is it an alphanumeric?
   030e   2e f1                        bgt     j_FBR        ; no, jump forward
   0310   81 41                        cmpa    #'A'
   0312   2d ed                        blt     j_FBR
   0314   48                           asla                 ; yes, double the ASCII code
                        			                        ; (make it a word index into var table
   0315   bd 01 94                     jsr     expr_push_byte ; push it on the stack
                                                            ; ...and consume this character
                        									; (fall thru to fetch_basicchar)
                        
                        ;------------------------------------------------------------------------------
                        ; get next BASIC char from program or line
                        ; return in A, Z=1 if CR
                        ;------------------------------------------------------------------------------
   0318                 fetch_basicchar:
   0318   de 2c                        ldx     basic_ptr    ; get address of current BASIC byte
   031a   a6 00                        ldaa    0,x          ; get byte
   031c   08                           inx                  ; advance to next character
   031d   df 2c                        stx     basic_ptr    ; save it
   031f   81 0d                        cmpa    #$D          ; check if 0x0d (end of line)
   0321   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; get next BASIC char (without advance)
                        ; C=1 if digit
                        ;------------------------------------------------------------------------------
   0322   8d f4         get_nchar:     bsr     fetch_basicchar ; get next char
   0324   81 20                        cmpa    #' '         ; is it a space?
   0326   27 fa                        beq     get_nchar    ; yes, skip that
   0328   09                           dex                  ; is no space, point back to this char
   0329   df 2c                        stx     basic_ptr
   032b   81 30                        cmpa    #'0'         ; is it a digit?
   032d   0c                           clc
   032e   2d 02                        blt     locret_33A   ; no, return C=0
   0330   81 3a                        cmpa    #':'         ; return C=1 if number
                        
   0332   39            locret_33A:    rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: branch if not number
                        ; if digit, convert this and following digits to number
                        ; and push on expr_stack
                        ;------------------------------------------------------------------------------
   0333   8d ed         IL_BN:         bsr     get_nchar    ; get BASIC char
   0335   24 ca                        bcc     j_FBR        ; if not digit, do forward branch
   0337   ce 00 00                     ldx     #0           ; clear temporary for number
   033a   df bc                        stx     IL_temp
                        
   033c   8d da         loop_bn:       bsr     fetch_basicchar ; get and consume this char
   033e   36                           psha                 ; save it
   033f   96 bc                        ldaa    IL_temp      ; multiply TEMP by 10
   0341   d6 bd                        ldab    IL_temp+1
   0343   58                           aslb                 ; temp*2
   0344   49                           rola
   0345   58                           aslb                 ; (temp*2)*2 = temp*4
   0346   49                           rola
   0347   db bd                        addb    IL_temp+1    ; (temp*4)+temp = temp*5
   0349   99 bc                        adca    IL_temp
   034b   58                           aslb                 ; (temp*5)*2 = temp*10
   034c   49                           rola
   034d   d7 bd                        stab    IL_temp+1
   034f   33                           pulb                 ; restore digit
   0350   c4 0f                        andb    #$F          ; mask out low nibble (0...9)
   0352   db bd                        addb    IL_temp+1    ; add into temp
   0354   89 00                        adca    #0
   0356   97 bc                        staa    IL_temp
   0358   d7 bd                        stab    IL_temp+1
   035a   8d c6                        bsr     get_nchar    ; get next char
   035c   25 de                        bcs     loop_bn      ; loop as long as digit found
   035e   96 bc                        ldaa    IL_temp      ; push A:B on expr_stack (B is still low byte)
   0360   7e 01 8d                     jmp     expr_push_word
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: divide
                        ;------------------------------------------------------------------------------
   0363   8d 73         IL_DV:         bsr     expr_check_4bytes ; validate 2 args on stack; discard 1 byte
   0365   a6 02                        ldaa    2,x          ; high byte dividend
   0367   47                           asra                 ; put sign into carry
   0368   49                           rola
   0369   a2 02                        sbca    2,x          ; A=0xFF if sign=1, 0x00 if sign=0
   036b   97 bc                        staa    IL_temp      ; sign extend dividend into 32bit (IL_temp=high word)
   036d   97 bd                        staa    IL_temp+1
   036f   16                           tab                  ; if negative, subtract 1 from dividend
   0370   eb 03                        addb    3,x          ; 0x0000...0x7fff stays positive
                                                            ; 0x8000 becomes positive
                                                            ; 0x8001...0xffff stays negative
   0372   e7 03                        stab    3,x
   0374   16                           tab
   0375   e9 02                        adcb    2,x
   0377   e7 02                        stab    2,x
   0379   a8 00                        eora    0,x          ; compare with sign of divisor
   037b   97 be                        staa    lead_zero    ; store result sign (negative if different, positive if same)
   037d   2a 02                        bpl     loc_389      ; if different sign, complement divisor
                                                            ; i.e. NEG/NEG -> do nothing
                                                            ;      NEG/POS -> NEG/NEG + lead_zero <0
                                                            ;      POS/NEG -> POS/POS + lead_zero <0
                                                            ;      POS/POS -> do nothing
   037f   8d 3b                        bsr     negate       ; negate operand
                        
   0381   c6 11         loc_389:       ldab    #$11         ; loop counter (16+1 iterations)
   0383   a6 00                        ldaa    0,x          ; is divisor = 0?
   0385   aa 01                        oraa    1,x
   0387   26 03                        bne     dv_loop      ; no, do division
   0389   7e 02 54                     jmp     error
                        
   038c   96 bd         dv_loop:       ldaa    IL_temp+1    ; subtract divisor from 32bit dividend
   038e   a0 01                        suba    1,x
   0390   36                           psha                 ; remember result
   0391   96 bc                        ldaa    IL_temp
   0393   a2 00                        sbca    0,x
   0395   36                           psha
   0396   98 bc                        eora    IL_temp
   0398   2b 09                        bmi     dv_smaller   ; subtract result was <0 ?
   039a   32                           pula                 ; no, can subtract, remember a 1 bit (sec)
   039b   97 bc                        staa    IL_temp      ; and store new result
   039d   32                           pula
   039e   97 bd                        staa    IL_temp+1
   03a0   0d                           sec
   03a1   20 03                        bra     dv_shift
                        
   03a3   32            dv_smaller:    pula                 ; discard subtraction
   03a4   32                           pula
   03a5   0c                           clc                  ; remember 0 bit
                        
   03a6   69 03         dv_shift:      rol     3,x          ; shift 32bit dividend left
   03a8   69 02                        rol     2,x          ; shift in result bit into lowest bit of dividend
   03aa   79 00 bd                     rol     IL_temp+1
   03ad   79 00 bc                     rol     IL_temp
   03b0   5a                           decb                 ; decrement loop
   03b1   26 d9                        bne     dv_loop      ; subtract divisor from  32bit dividend
   03b3   8d 20                        bsr     j_expr_pop_byte ; drop a byte (other one was already removed above)
                                                            ; X points to result in (former) dividend at 2,X
   03b5   7d 00 be                     tst     lead_zero    ; operand signs were different?
   03b8   2a 0a                        bpl     locret_3CC   ; no, we are done
                        			                        ; else fall thru to negation (of result)
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: negate top of stack
                        ;------------------------------------------------------------------------------
   03ba   de c2         IL_NE:         ldx     expr_stack_x ; point to TOS
   03bc   60 01         negate:        neg     1,x          ; negate low byte
   03be   26 02                        bne     ne_nocarry   ; not zero: no carry
   03c0   6a 00                        dec     0,x          ; propagate carry into high byte
                        
   03c2   63 00         ne_nocarry:    com     0,x          ; complement high byte
                        
   03c4   39            locret_3CC:    rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: subtract TOS from NOS -> NOS
                        ;------------------------------------------------------------------------------
   03c5   8d f3         IL_SU:         bsr     IL_NE        ; negate TOS. A-B is A+(-B)
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: add TOS and NOS -> NOS
                        ;------------------------------------------------------------------------------
   03c7   8d 0f         IL_AD:         bsr     expr_check_4bytes ; verify 4 bytes on stack
   03c9   e6 03                        ldab    3,x          ; add TOS and NOS into AB
   03cb   eb 01                        addb    1,x
   03cd   a6 02                        ldaa    2,x
   03cf   a9 00                        adca    0,x
                        
   03d1   a7 02         expr_save_pop: staa    2,x          ; store A:B in NOS and pop further byte
   03d3   e7 03                        stab    3,x
                        
   03d5   7e 01 a9      j_expr_pop_byte: jmp   expr_pop_byte
                        
                        ;------------------------------------------------------------------------------
                        ; validate stack contains at least 4 bytes, pop 1 byte
                        ;------------------------------------------------------------------------------
   03d8   c6 04         expr_check_4bytes: ldab #4
                        
   03da   7e 01 ab      expr_check_nbytes: jmp  pop_byte    ; pop a byte
                        
                        ;------------------------------------------------------------------------------
                        ; multiply TOS with NOS -> NOS
                        ; I think this this routine is broken for negative numbers
                        ;------------------------------------------------------------------------------
   03dd   8d f9         IL_MP:         bsr     expr_check_4bytes ; validate 2 args
   03df   86 10                        ldaa    #$10         ; bit count (16 bits)
   03e1   97 bc                        staa    IL_temp
   03e3   4f                           clra                 ; clear bottom 16 bits of result
   03e4   5f                           clrb
                        
   03e5   58            mp_loop:       aslb                 ; shift 1 bit left
   03e6   49                           rola
   03e7   68 01                        asl     1,x          ; shift 1st operand
   03e9   69 00                        rol     0,x
   03eb   24 04                        bcc     mp_notadd    ; is top bit = 1?
   03ed   eb 03                        addb    3,x          ; yes, add 2nd operand into A:B
   03ef   a9 02                        adca    2,x
                        
   03f1   7a 00 bc      mp_notadd:     dec     IL_temp      ; decrement counter
   03f4   26 ef                        bne     mp_loop      ; loop 16 times
   03f6   20 d9                        bra     expr_save_pop ; save result
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: fetch variable
                        ;------------------------------------------------------------------------------
   03f8   8d db         IL_FV:         bsr     j_expr_pop_byte ; get byte (variable address into zero page)
   03fa   d7 bd                        stab    IL_temp+1    ; make pointer into var table
   03fc   7f 00 bc                     clr     IL_temp
   03ff   de bc                        ldx     IL_temp
   0401   a6 00                        ldaa    0,x          ; get word indexed by X into A:B
   0403   e6 01                        ldab    1,x
   0405   7e 01 8d                     jmp     expr_push_word ; push it onto expr_stack
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: save variable
                        ;------------------------------------------------------------------------------
   0408   c6 03         IL_SV:         ldab    #3
   040a   8d ce                        bsr     expr_check_nbytes ; validate stack contains var index byte
                                                            ; and data word. drop single byte
   040c   e6 01                        ldab    1,x          ; get low byte of data in B
   040e   6f 01                        clr     1,x          ; clear this to build word index to var
   0410   a6 00                        ldaa    0,x          ; get high byte of data in A
   0412   ee 01                        ldx     1,x          ; load index into variable table
   0414   a7 00                        staa    0,x          ; save A:B into variable
   0416   e7 01                        stab    1,x
                        
   0418   7e 01 a6      j_IL_SP:       jmp     IL_SP        ; pop word off stack
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction compare
                        ; stack: TOS, MASK, NOS
                        ; compare TOS with NOS
                        ; MASK is bit0 = less
                        ;      bit1 = equal
                        ;      bit2 = greater
                        ; if compare reslut AND    mask return <>0, next IL op is skipped
                        ;------------------------------------------------------------------------------
   041b   8d fb         IL_CP:         bsr     j_IL_SP      ; pop TOS into A:B
   041d   37                           pshb                 ; save low byte
   041e   c6 03                        ldab    #3
   0420   8d b8                        bsr     expr_check_nbytes ; verify still 3 bytes on stack,
                        			                        ; drop one byte
   0422   7c 00 c3                     inc     expr_stack_top ; drop more bytes
   0425   7c 00 c3                     inc     expr_stack_top
   0428   33                           pulb                 ; restore low byte of TOS
   0429   e0 02                        subb    2,x          ; compare with 1st arg
                                                            ; note this subtraction is inverted
                        									; thus BGT means BLT, and vice versa
   042b   a2 01                        sbca    1,x
   042d   2e 0b                        bgt     cp_is_lt     ; if less, skip
   042f   2d 05                        blt     cp_is_gt     ; if greater, skip
   0431   5d                           tstb                 ; is result 0?
   0432   27 04                        beq     cp_is_eq
   0434   20 04                        bra     cp_is_lt
                        
   0436   67 00         cp_is_gt:      asr     0,x          ; shift bit 2 into carry
                        
   0438   67 00         cp_is_eq:      asr     0,x          ; shift bit 1 into carry
                        
   043a   67 00         cp_is_lt:      asr     0,x          ; shift bit 0 into carray
   043c   24 1b                        bcc     locret_461   ; not matched: exit, continue new IL op
   043e   7e 01 f5                     jmp     fetch_il_op  ; skip one IL op before continuing
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: advance to next BASIC line
                        ;------------------------------------------------------------------------------
   0441   96 c0         IL_NX:         ldaa    run_mode     ; run mode = 0?
   0443   27 1d                        beq     loc_46A      ; yes, continue program
                        
   0445                 nx_loop:                ; ...
   0445   bd 03 18                     jsr     fetch_basicchar ; get char from program
   0448   26 fb                        bne     nx_loop      ; is not CR, loop
   044a   8d 1d                        bsr     save_lineno  ; store line number
   044c   27 11                        beq     j1_error     ; is 0000 (end of program) -> error
                        
                        ;------------------------------------------------------------------------------
                        ; enters here from a GOTO,
                        ; basic pointer points to new line
                        ;------------------------------------------------------------------------------
   044e   8d 32         go_found_line: bsr    do_runmode    ; set run mode = running
   0450   bd 01 0c                     jsr    BV            ; test for BREAK
   0453   25 05                        bcs    do_break      ; if C=1, do break
   0455   de c4                        ldx    il_pc_save    ; restore IL_PC which was saved in XQ or GO
   0457   df 2a                        stx    il_pc
                        
   0459   39            locret_461:    rts
                        
   045a   fe 01 fe      do_break:      ldx    IL_baseaddr   ; restart interpreter
   045d   df 2a                        stx    il_pc
                        
   045f   7e 02 54      j1_error:      jmp    error         ; and emit break error
                        
                        ;------------------------------------------------------------------------------
                        ; fragment of code for IL_NX
                        ;------------------------------------------------------------------------------
   0462   9e 26         loc_46A:       lds     top_of_stack ; reload stack
   0464   97 bf                        staa    column_cnt   ; clear column count (A was 0)
   0466   7e 02 22                     jmp     restart_il_nocr ; restart interpreter
                        
                        ;------------------------------------------------------------------------------
                        ; save current linenumber
                        ;------------------------------------------------------------------------------
   0469   bd 03 18      save_lineno:   jsr     fetch_basicchar ; get char from program code
   046c   97 28                        staa    basic_lineno    ; save as high lineno
   046e   bd 03 18                     jsr     fetch_basicchar ; get char from program code
   0471   97 29                        staa    basic_lineno+1  ; save as low lineno
   0473   de 28                        ldx     basic_lineno    ; load line number for later
   0475   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: execute program
                        ;------------------------------------------------------------------------------
   0476   de 20         IL_XQ:         ldx     start_prgm   ; set current start of program
   0478   df 2c                        stx     basic_ptr
   047a   8d ed                        bsr     save_lineno  ; save current line number
   047c   27 e1                        beq     j1_error     ; if zero, error
   047e   de 2a                        ldx     il_pc        ; save current IL_PC
   0480   df c4                        stx     il_pc_save
                        
   0482   07            do_runmode:    tpa                  ; will load non zero value (0xc0) into A - tricky!
   0483   97 c0                        staa    run_mode     ; set run_mode = "running"
   0485   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction GO
                        ;------------------------------------------------------------------------------
   0486   bd 05 12      IL_GO:         jsr     find_line    ; find line which lineno is on stack
   0489   27 c3                        beq     go_found_line ; found? yes, skip
                        
   048b   de bc         go_error:      ldx     IL_temp      ; set requested lineno as current
   048d   df 28                        stx     basic_lineno
   048f   20 ce                        bra     j1_error     ; error - line not found
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: restore saved line
                        ;------------------------------------------------------------------------------
   0491   8d 61         IL_RS:         bsr     get_payload  ; get saved line 2 levels off stack
   0493   30                           tsx                  ; point to caller of exec_il_opcode
   0494   6c 01                        inc     1,x          ; hack: adjust return from exec_il_mainloop
                                                            ; that it points to il_rs_target just below
                                                            ; il_mainloop
   0496   6c 01                        inc     1,x
   0498   bd 05 1d                     jsr     find_line1   ; find the basic line
   049b   26 ee                        bne     go_error     ; line not found? -> error
   049d   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction return from IL call
                        ;------------------------------------------------------------------------------
   049e   8d 54         IL_RT:         bsr     get_payload  ; get saved IL PC address
   04a0   df 2a                        stx     il_pc        ; restore it to IL_PC
   04a2   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction save BASIC pointer
                        ;------------------------------------------------------------------------------
   04a3   ce 00 2c      IL_SB:         ldx     #basic_ptr   ; get address of basic pointer
   04a6   20 03                        bra     loc_4B3      ; continue in IL_RB common code
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: restore BASIC pointer
                        ;------------------------------------------------------------------------------
   04a8   ce 00 2e      IL_RB:         ldx     #basicptr_save
                        
   04ab   a6 01         loc_4B3:       ldaa    1,x          ; is it into the input line area?
   04ad   81 80                        cmpa    #$80
   04af   24 08                        bcc     swap_bp      
   04b1   a6 00                        ldaa    0,x
   04b3   26 04                        bne     swap_bp      ; no, do swap with save location
   04b5   de 2c                        ldx     basic_ptr
   04b7   20 0a                        bra     loc_4CB
                        
   04b9   de 2c         swap_bp:       ldx     basic_ptr    ; get basic pointer
   04bb   96 2e                        ldaa    basicptr_save ; move saved pointer to basic ptr
   04bd   97 2c                        staa    basic_ptr
   04bf   96 2f                        ldaa    basicptr_save+1
   04c1   97 2d                        staa    basic_ptr+1
                        
   04c3   df 2e         loc_4CB:       stx     basicptr_save ; store old basic pointer into save
   04c5   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction gosub
                        ;------------------------------------------------------------------------------
   04c6   30            IL_GS:         tsx
   04c7   6c 01                        inc     1,x          ; adjust return address to il_rs_target
   04c9   6c 01                        inc     1,x
   04cb   de 28                        ldx     basic_lineno ; get line number of GOSUB
   04cd   df bc                        stx     IL_temp      ; store it in temp
                        			                        ; an fall thru to payload saver which
                                                            ; injects temp into return stack
                        
                        ;------------------------------------------------------------------------------
                        ; insert IL_temp into return stack
                        ;
                        ; stack holds (low to high addresses)
                        ; SP->
                        ;   return address of exec_il_opcode
                        ;   other data
                        ;
                        ; afterwards
                        ; SP ->
                        ;   return address of exec_il_opcode
                        ;   payload
                        ;   other data
                        ;------------------------------------------------------------------------------
   04cf   34            push_payload:  des                  ; reserve 2 bytes on processor stack
   04d0   34                           des
   04d1   30                           tsx                  ; get address in X
   04d2   a6 02                        ldaa    2,x          ; duplicate return address
   04d4   a7 00                        staa    0,x
   04d6   a6 03                        ldaa    3,x
   04d8   a7 01                        staa    1,x
   04da   96 bc                        ldaa    IL_temp      ; insert return address for JS instruction in stack
   04dc   a7 02                        staa    2,x
   04de   96 bd                        ldaa    IL_temp+1
   04e0   a7 03                        staa    3,x
   04e2   ce 00 24                     ldx     #end_prgm    ; address of end of program
   04e5   9f bc                        sts     IL_temp      ; save current stack in temporary
   04e7   a6 01                        ldaa    1,x          ; check that stack does not run into program code
   04e9   90 bd                        suba    IL_temp+1
   04eb   a6 00                        ldaa    0,x
   04ed   92 bc                        sbca    IL_temp
   04ef   25 20                        bcs     locret_519   ; is still space available?
                                                            ; yes, exit
   04f1   7e 02 54      j2_error:      jmp    error         ; no error
                        
                        ;------------------------------------------------------------------------------
                        ; return payload in X
                        ;
                        ; stack:
                        ; X
                        ; 0  returnaddr    caller of get_payload
                        ; 1  returnaddr    caller of get_payload
                        ; 2  returnaddr    caller of exec_il_opcode
                        ; 3  returnaddr    caller of exec_il_opcode
                        ; 4  payload
                        ; 5  payload
                        ;------------------------------------------------------------------------------
   04f4   30            get_payload:   tsx                  ; copy return stack addr to X
   04f5   08                           inx                  ; pointing to return address
   04f6   08                           inx                  ; skip over return address and 2 more bytes
                                                            ; point to index 3
   04f7   08                           inx
   04f8   9c 22                        cpx     end_ram      ; stack underflow?
   04fa   27 f5                        beq     j2_error     ; yes, error
   04fc   ee 01                        ldx     1,x          ; get payload into X
   04fe   df bc                        stx     IL_temp      ; save it
   0500   30                           tsx                  ; point to return address
   0501   37                           pshb                 ; save B
   0502   c6 04                        ldab    #4           ; move 4 bytes above
                        
   0504   a6 03         gp_loop:       ldaa    3,x
   0506   a7 05                        staa    5,x
   0508   09                           dex
   0509   5a                           decb
   050a   26 f8                        bne     gp_loop      ; loop until done
   050c   33                           pulb                 ; restore B
   050d   31                           ins                  ; drop 1 word (duplicate return address)
   050e   31                           ins
   050f   de bc                        ldx     IL_temp      ; get payload
                        
   0511   39            locret_519:    rts                  ; done
                        
                        ;------------------------------------------------------------------------------
                        ; find BASIC line whose lineno is on stack
                        ; discard from stack
                        ; return found line in basic_ptr
                        ; Z=1 if line is matched exactly
                        ;------------------------------------------------------------------------------
   0512   bd 01 a6      find_line:     jsr     IL_SP        ; pop word into A:B
   0515   d7 bd                        stab    IL_temp+1    ; save in temporary
   0517   97 bc                        staa    IL_temp
   0519   9a bd                        oraa    IL_temp+1    ; check if zero (invalid)
   051b   27 d4                        beq     j2_error     ; if so, error
                        
                                       ; find BASIC line whose lineno is in IL_temp
   051d   de 20         find_line1:    ldx     start_prgm   ; set BASIC pointer to start
   051f   df 2c                        stx     basic_ptr
                        
   0521   bd 04 69      test_line:     jsr     save_lineno  ; save current lineno
                                                            ; note: X = lineno
   0524   27 11                        beq     find_exit    ; if zero, skip to end
   0526   d6 29                        ldab    basic_lineno+1 ; compare line number with current line
   0528   96 28                        ldaa    basic_lineno
   052a   d0 bd                        subb    IL_temp+1
   052c   92 bc                        sbca    IL_temp
   052e   24 07                        bcc     find_exit    ; if above, exit
                        
   0530   bd 03 18      find_eoln:     jsr     fetch_basicchar ; get next char
   0533   26 fb                        bne     find_eoln    ; not CR? loop
   0535   20 ea                        bra     test_line    ; check next line
                        
   0537   9c bc         find_exit:     cpx     IL_temp      ; compare current linenumber with searched one
   0539   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; emit number in A:B
                        ;------------------------------------------------------------------------------
   053a   bd 01 8d      emit_number:   jsr     expr_push_word ; push number on stack
                        
   053d   de c2         IL_PN:         ldx     expr_stack_x ; get address of stack top
   053f   6d 00                        tst     0,x          ; is number negative?
   0541   2a 07                        bpl     loc_552      ; no, skip
   0543   bd 03 ba                     jsr     IL_NE        ; negate top of stack
   0546   86 2d                        ldaa    #'-'         ; emit negative sign
   0548   8d 46                        bsr     emit_char
                        
   054a   4f            loc_552:       clra                 ; push 0 (end of digits)
   054b   36                           psha
   054c   c6 0f                        ldab    #$F
   054e   86 1a                        ldaa    #$1A
   0550   36                           psha                 ; counter for 10's (0x1A)
   0551   37                           pshb                 ; counter for 100's (0x0F)
   0552   36                           psha                 ; counter for 1000's, (0x1A)
   0553   37                           pshb                 ; counter for 10000's (0x0f)
   0554   bd 01 a6                     jsr     IL_SP        ; pop TOS into A:B
   0557   30                           tsx                  ; point to the constants 0xF, 0x1A....
                        
   0558   6c 00         loop_10000s:   inc     0,x          ; increment counter for 10000's
   055a   c0 10                        subb    #$10         ; subtract 10000 (0x2710) until negative
   055c   82 27                        sbca    #$27
   055e   24 f8                        bcc     loop_10000s  ; counter for 10000's will become 0x10...0x14
                        
   0560   6a 01         loop_1000s:    dec     1,x          ; is now negative value, subtract until positive again
   0562   cb e8                        addb    #$E8         ; add 1000 (0x3e8) until positive again 
   0564   89 03                        adca    #3           ; decrement counter for 1000's
   0566   24 f8                        bcc     loop_1000s   ; counter for 1000's will become 0x19...0x10
                        
   0568   6c 02         loop_100s:     inc     2,x          ; is positive value now
   056a   c0 64                        subb    #$64         ; subtract 100 (0x54) until negative
   056c   82 00                        sbca    #0
   056e   24 f8                        bcc     loop_100s    ; counter for 100's becomes 0x10...0x19
                        
   0570   6a 03         loop_10s:      dec     3,x          ; is now negative
   0572   cb 0a                        addb    #$A          ; add 10 until positive again
   0574   24 fa                        bcc    loop_10s      ; counter for 10's become 0x10..0x19
                                                            ; B contains remianing 1's digits
   0576   7f 00 be                     clr     lead_zero    ; clear flag to suppress leading zeroes
                        
   0579   32            emit_digits:   pula                 ; restore counter 10000
   057a   4d                           tsta                 ; was zero?
   057b   27 04                        beq     last_digit   ; yes, last digit to emit, this one is in B
   057d   8d 03                        bsr     emit_digit   ; emit digit in A, suppress leading zeroes
   057f   20 f8                        bra     emit_digits  ; guarantee last digit is printed.
                        
   0581   17            last_digit:    tba                  ; last digit is in B
                        
   0582   81 10         emit_digit:    cmpa    #$10         ; check if '0' (note range is 0x10..19 if not last digit)
   0584   26 05                        bne     emit_digit1  ; no, must emit
                                                            ; note for last digit, any value will be emitted,
                                                            ; because it can't be 0x10 (is 0...9)
   0586   7d 00 be                     tst     lead_zero    ; already emitted a digit?
   0589   27 17                        beq     locret_5AA   ; no, exit (leading zero)
                        
   058b   7c 00 be      emit_digit1:   inc     lead_zero    ; notify digit print
   058e   8a 30                        oraa    #'0'         ; make it a real ASCII '0'...'9'
                                                            ; and print it, by fallthru to emit_char
                        
                        ;------------------------------------------------------------------------------
                        ; emit a character in A
                        ;------------------------------------------------------------------------------
   0590   7c 00 bf      emit_char:     inc     column_cnt   ; advance to column 1
   0593   2b 0a                        bmi     loc_5A7      ; if at column 128, stop emit
   0595   df ba                        stx     X_save       ; save X
   0597   37                           pshb                 ; save B
   0598   bd 01 09                     jsr     OUT_V        ; emit character
   059b   33                           pulb                 ; restore B
   059c   de ba                        ldx     X_save       ; restore X
   059e   39                           rts                  ; done
                        
   059f   7a 00 bf      loc_5A7:       dec     column_cnt   ; if column = 0x80, don't advance further
                        
   05a2   39            locret_5AA:    rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction print string
                        ;------------------------------------------------------------------------------
   05a3   8d eb         pc_loop:       bsr     emit_char    ; emit a character and continue 
                                                            ; with PC instruction
                        
   05a5   bd 01 f5      IL_PC:         jsr     fetch_il_op  ; get next byte of instruction
   05a8   2a f9                        bpl     pc_loop      ; if positive, skip
   05aa   20 e4                        bra     emit_char    ; was last char, emit it and terminate
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction PQ
                        ;------------------------------------------------------------------------------
   05ac   81 22         loop_pq:       cmpa    #'"'         ; is character string terminator?
   05ae   27 f2                        beq     locret_5AA   ; yes, exit
   05b0   8d de                        bsr     emit_char    ; otherwise emit char
                                                            ; and redo PQ instruction
                        
   05b2   bd 03 18      IL_PQ:         jsr     fetch_basicchar ; get next char from BASIC text
   05b5   26 f5                        bne     loop_pq      ; if not CR, loop
   05b7   7e 02 54                     jmp     error        ; error - unterminated string
                        
                        ;------------------------------------------------------------------------------
                        ;  IL instruction print tab
                        ;------------------------------------------------------------------------------
   05ba   d6 bf         IL_PT:         ldab    column_cnt   ; column counter
   05bc   2b e4                        bmi     locret_5AA   ; if overflow, exit
   05be   ca f8                        orab    #$F8         ; make 7...0
   05c0   50                           negb
   05c1   20 03                        bra     pt_loop      ; jump to space printer
                        
   05c3   bd 01 a6      pt_print_spc:  jsr     IL_SP        ; drop A:B off stack
                        
   05c6   5a            pt_loop:       decb                 ; decrement low byte
   05c7   2d d9                        blt     locret_5AA   ; < 0, exit
   05c9   86 20                        ldaa    #' '         ; emit a space
   05cb   8d c3                        bsr     emit_char
   05cd   20 f7                        bra     pt_loop      ; loop
                        
                        ;------------------------------------------------------------------------------
                        ; IL Instruction List BASIC source
                        ;------------------------------------------------------------------------------
   05cf   de 2c         IL_LS:         ldx     basic_ptr    ; save current BASIC pointer
   05d1   df b8                        stx     BP_save
   05d3   de 20                        ldx     start_prgm   ; default start: begin of program
   05d5   df 2c                        stx     basic_ptr
   05d7   de 24                        ldx     end_prgm     ; default end: load X with end of program
   05d9   8d 2c                        bsr     ls_getlineno ; if argument to list given, make this new end
                                                            ; note "LIST start,end", so the first result
                                                            ; popped off stack is the end
   05db   27 02                        beq     ls_nostart   ; no more argument on stack
   05dd   8d 28                        bsr     ls_getlineno ; save first position in LS_begin
                                                            ; get another argument into basic_ptr, if any
                        
   05df   96 2c         ls_nostart:    ldaa    basic_ptr    ; compare start and end of listing
   05e1   d6 2d                        ldab    basic_ptr+1
   05e3   d0 b7                        subb    LS_end+1
   05e5   92 b6                        sbca    LS_end
   05e7   24 32                        bcc     ls_exit      ; start > end? yes, exit: nothing (more) to list
   05e9   bd 04 69                     jsr     save_lineno  ; save lineno of current line
   05ec   27 2d                        beq     ls_exit      ; is end of program (line 0)? yes, exit
   05ee   96 28                        ldaa    basic_lineno ; get current line number
   05f0   d6 29                        ldab    basic_lineno+1
   05f2   bd 05 3a                     jsr     emit_number  ; print line number
   05f5   86 20                        ldaa    #' '         ; print a space
                        
   05f7   8d 4c         ls_loop:       bsr     j_emitchar
   05f9   bd 01 0c                     jsr     BV           ; check for break
   05fc   25 1d                        bcs     ls_exit      ; if break, exit
   05fe   bd 03 18                     jsr     fetch_basicchar ; get next char from line
   0601   26 f4                        bne     ls_loop      ; if not CR, loop output
   0603   8d 1b                        bsr     IL_NL        ; emit a CRLF
   0605   20 d8                        bra     ls_nostart   ; loop with next line
                        
                        ;------------------------------------------------------------------------------
                        ; called with an address into BASIC code
                        ; return Z=1 if no argument
                        ;------------------------------------------------------------------------------
   0607   08            ls_getlineno:  inx                  ; increment X
   0608   df b6                        stx    LS_end        ; store as default end of listing
   060a   de c2                        ldx    expr_stack_x  ; get expr_stack ptr
   060c   8c 00 80                     cpx    #$80          ; is stack empty?
   060f   27 09                        beq    locret_622    ; yes, no arg given...done
   0611   bd 05 12                     jsr    find_line     ; find the line (after the lineno) that was given on
                                                            ; stack (start line number)
                                                            ; result in X=basic_ptr
                        
   0614   de 2c         ls_to_linestart: ldx    basic_ptr   ; point back to lineno that was found
   0616   09                           dex
   0617   09                           dex
   0618   df 2c                        stx    basic_ptr     
                        
   061a   39            locret_622:    rts
                        
   061b   de b8         ls_exit:       ldx    BP_save       ; restore old BASIC pointer
   061d   df 2c                        stx    basic_ptr
   061f   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: emit new line
                        ;------------------------------------------------------------------------------
   0620   96 bf         IL_NL:         ldaa    column_cnt   ; if column > 127, suppress output
   0622   2b f6                        bmi     locret_622
                        
                        ;------------------------------------------------------------------------------
                        ; do a CRLF
                        ;------------------------------------------------------------------------------
   0624   86 0d         crlf:          ldaa    #$D          ; emit carriage return character
   0626   8d 1a                        bsr     emit_char_at_0
   0628   f6 01 11                     ldab    PCC          ; get padding mode
   062b   58                           aslb                 ; shift out bit 7
   062c   27 09                        beq     loc_63E      ; if no padding bytes, skip
                        
   062e   37            loc_636:       pshb                 ; save padding count
   062f   8d 0a                        bsr     emit_nul_padding ; emit padding
   0631   33                           pulb                 ; restore count
   0632   5a                           decb                 ; decrement twice (because above 
   0633   58            			   aslb                 ; multiplied *2)
   0634   5a                           decb
   0635   26 f7                        bne     loc_636      ; loop until done
                        
   0637   86 0a         loc_63E:       ldaa    #$A          ; emit line feed character
   0639   8d 0a                        bsr     j_emitchar   ; emit character (with increment column count)
                        
                                                            ; depending on PCC bit 7 emit 
                        									; either NUL or DEL (0xff) byte
   063b   4f            emit_nul_padding: clra              ; padding byte
   063c   7d 01 11                     tst     PCC          ; check if bit 7 of PCC:
                                                            ; =0, emit NUL bytes
                                                            ; =1, emit 0xFF bytes
   063f   2a 01                        bpl     emit_char_at_0 ; emit a NUL byte
   0641   43                           coma
                        
                                       ; emit a char in A and clear column count/XOFF mode
   0642   7f 00 bf      emit_char_at_0: clr    column_cnt   ; reset column to 0
                        
   0645   7e 05 90      j_emitchar:    jmp     emit_char
                        
   0648   b6 01 12      do_xon:        ldaa    TMC          ; get XOFF flag
   064b   20 01                        bra     loc_655
                        
   064d   4f            do_xoff:       clra
                        
   064e   97 bf         loc_655:       staa    column_cnt   ; save column count
   0650   20 0a                        bra     gl_loop
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: get input line
                        ; uses expr_stack as buffer
                        ;------------------------------------------------------------------------------
   0652   ce 00 30      IL_GL:         ldx     #expr_stack  ; store floor of expr_stack as BASIC pointer
   0655   df 2c                        stx     basic_ptr
   0657   df bc                        stx     IL_temp      ; save pointer to char input into buffer
   0659   bd 01 8d                     jsr     expr_push_word ; save A:B for later (may be variable address, or alike)
                        
   065c   98 80         gl_loop:       eora    rnd_seed     ; use random A to create some entropy
   065e   97 80                        staa    rnd_seed
   0660   bd 01 06                     jsr     IN_V         ; get a char from input device
   0663   84 7f                        anda    #$7F         ; make 7bit ASCII
   0665   27 f5                        beq     gl_loop      ; if NUL, ignore
   0667   81 7f                        cmpa    #$7F         ; if 0xFF/0x7F, ignore
   0669   27 f1                        beq     gl_loop
   066b   81 0a                        cmpa    #$A          ; if LF, done
   066d   27 d9                        beq     do_xon
   066f   81 13                        cmpa    #$13         ; if DC3 (XOFF) handle XOFF
   0671   27 da                        beq     do_xoff
   0673   de bc                        ldx     IL_temp      ; get buffer pointer
   0675   b1 01 10                     cmpa    LSC          ; line cancel?
   0678   27 0a                        beq     gl_ctrlx
   067a   b1 01 0f                     cmpa    BSC          ; is it "_" ? (back character)
   067d   26 0c                        bne     gl_chkend    ; no, skip
   067f   8c 00 30                     cpx     #expr_stack  ; at start of buffer?
   0682   26 15                        bne     gl_dobackspace ; no, do a backspace
                        
   0684   de 2c         gl_ctrlx:      ldx     basic_ptr    ; reset pointer to input char
   0686   86 0d                        ldaa    #$D          ; load CR
   0688   7f 00 bf                     clr     column_cnt   ; do XON
                        
   068b   9c c2         gl_chkend:     cpx     expr_stack_x ; is end of buffer reached?
   068d   26 06                        bne     gl_savechar  ; no, skip
   068f   86 07                        ldaa    #7           ; emit BEL character (line overflow)
   0691   8d b2                        bsr     j_emitchar
   0693   20 c7                        bra     gl_loop      ; loop
                        
   0695   a7 00         gl_savechar:   staa    0,x          ; save char in buffer
   0697   08                           inx                  ; advance
   0698   08                           inx
                        
   0699   09            gl_dobackspace:  dex
   069a   df bc                        stx     IL_temp      ; !!! error in dump, was 0F
                                                            ; save new ptr to input
   069c   81 0d                        cmpa    #$D          ; was char CR?
   069e   26 bc                        bne     gl_loop      ; no, get another char
   06a0   bd 06 20                     jsr     IL_NL        ; end of input reached
   06a3   96 bd                        ldaa    IL_temp+1    ; get buffer line
   06a5   97 c1                        staa    expr_stack_low ; save as new expr_stack bottom
                                                            ; (should not overwrite buffer)
   06a7   7e 01 a6                     jmp     IL_SP        ; pop old value off stack
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: insert BASIC line
                        ;------------------------------------------------------------------------------
   06aa   bd 04 b9      IL_IL:         jsr     swap_bp      ; basicptr_save = 0x80 (input buffer)
                                                            ; basic_ptr = invalid
   06ad   bd 05 12                     jsr     find_line    ; search for line with lineno from stack
                                                            ; if found: address of BASIC text in basic_ptr
                                                            ; if not: address of next line or end of program
   06b0   07                           tpa                  ; save status, whether line was found
   06b1   bd 06 14                     jsr     ls_to_linestart ; adjust line back to lineno
   06b4   df b8                        stx     BP_save      ; save this in BP_save as well.
                                                            ; basic_ptr==BP_save is position where to enter
                                                            ; new line (if same lineno, overwrite)
   06b6   de bc                        ldx     IL_temp      ; save lineno to be handled in LS_end
   06b8   df b6                        stx     LS_end
   06ba   5f                           clrb                 ; preload length of stored line with 0
                                                            ; for line not found (must grow)
   06bb   06                           tap                  ; restore status of find_line
   06bc   26 0b                        bne     il_linenotfound ; skip if lineno not matched
                                                            ; hey, this line already exists!
   06be   bd 04 69                     jsr     save_lineno  ; save lineno where we are currently in basic_lineno
   06c1   c6 fe                        ldab    #$FE         ; advance to end of line,
                                                            ; B is negative length of line
                        
   06c3   5a            il_findeoln:   decb
   06c4   bd 03 18                     jsr     fetch_basicchar
   06c7   26 fa                        bne     il_findeoln  ; loop until end of line
                                                            ; B now contains negative sizeof(stored line)
                        
   06c9   ce 00 00      il_linenotfound: ldx   #0           ; B is 0, if line does not yet exist
   06cc   df 28                        stx     basic_lineno ; clear lineno
   06ce   bd 04 b9                     jsr     swap_bp      ; basic_ptr = 0x80 (input buffer)
                                                            ; basicptr_save = at end of position to insert
                                                            ; (i.e. either before following line, or at end of
                                                            ; line to be grown/shrunk)
   06d1   86 0d                        ldaa    #$D          ; calculate sizeof(input buffer)
                                                            ; load EOLN char
   06d3   de 2c                        ldx    basic_ptr     ; start at input buffer (after line number)
   06d5   a1 00                        cmpa    0,x          ; is it eoln?
   06d7   27 0c                        beq     loc_6EC      ; yes, skip - this is an empty line: must delete
   06d9   cb 03                        addb    #3           ; no, reserve 3 bytes for lineno and CR
                        
   06db   5c            loc_6E2:       incb                 ; increment B for every byte in current line <> eoln
   06dc   08                           inx
   06dd   a1 00                        cmpa    0,x          ; advance and check for EOLN
   06df   26 fa                        bne     loc_6E2      ; loop until eoln found
                                                            ;
                                                            ; all in all, B contains the difference of line lengths:
                                                            ;  -sizeof(stored line)+sizeof(input buffer)
                                                            ; if negative: stored is longer  than new -> shrink program
                                                            ; if zero: stored is same size
                                                            ; if positive: stored is shorter than new -> grow program
   06e1   de b6                        ldx     LS_end       ; restore current lineno
                                                            ; is non-null: there is a line to add
   06e3   df 28                        stx     basic_lineno
                        
   06e5   de b8         loc_6EC:       ldx     BP_save      ; IL_temp = start of area to insert line
   06e7   df bc                        stx     IL_temp
   06e9   5d                           tstb                 ; check number of bytes
                                                            ; negative: shrink program
                                                            ; zero: nothing to move
                                                            ; positive: grow program
   06ea   27 55                        beq     il_samesize  ; same size, just copy
   06ec   2a 23                        bpl     il_growline  ; stored line is longer -> shrink
   06ee   96 2f                        ldaa    basicptr_save+1 ; BP_save = end_of_insert - bytes to shrink
   06f0   1b                           aba
   06f1   97 b9                        staa    BP_save+1
   06f3   96 2e                        ldaa    basicptr_save
   06f5   89 ff                        adca    #$FF
   06f7   97 b8                        staa    BP_save      ; BP_save < basicptr_save < end_pgrm < top_of_stack (hopefully)
                        
   06f9   de 2e         il_shrink:     ldx     basicptr_save ; copy from end of insert addr to BP_save addr
   06fb   e6 00                        ldab    0,x
   06fd   9c 24                        cpx     end_prgm     ; until end of program
   06ff   27 3c                        beq     loc_744
   0701   9c 26                        cpx     top_of_stack ; or until top_of_stack
   0703   27 38                        beq     loc_744      ; leave, when done
   0705   08                           inx                  ; advance
   0706   df 2e                        stx     basicptr_save
   0708   de b8                        ldx     BP_save
   070a   e7 00                        stab    0,x          ; save the byte
   070c   08                           inx
   070d   df b8                        stx     BP_save
   070f   20 e8                        bra     il_shrink    ; loop until done
                        
   0711   db 25         il_growline:   addb    end_prgm+1   ; make space after end of program for B bytes
   0713   d7 2f                        stab    basicptr_save+1
   0715   86 00                        ldaa    #0
   0717   99 24                        adca    end_prgm
   0719   97 2e                        staa    basicptr_save ; basicptr_save = new end of program
   071b   d0 27                        subb    top_of_stack+1
   071d   92 26                        sbca    top_of_stack ; verify it's below top_of_RAM
   071f   25 06                        bcs     il_dogrow    ; ok, continue
   0721   7a 00 2b                     dec     il_pc+1      ; point back to IL instruction
   0724   7e 02 54                     jmp     error        ; overflow error
                        
   0727   de 2e         il_dogrow:     ldx     basicptr_save ; BP_save is new end of program
   0729   df b8                        stx     BP_save
                        
   072b   de 24         il_grow:       ldx     end_prgm     ; get byte from old end of program
   072d   a6 00                        ldaa    0,x
   072f   09                           dex                  ; advance back
   0730   df 24                        stx     end_prgm
   0732   de 2e                        ldx     basicptr_save ; store byte at new end of program
   0734   a7 00                        staa    0,x
   0736   09                           dex
   0737   df 2e                        stx     basicptr_save
   0739   9c bc                        cpx     IL_temp
   073b   26 ee                        bne     il_grow      ; loop until done
                        
   073d   de b8         loc_744:       ldx     BP_save      ; adjust new end of program
   073f   df 24                        stx     end_prgm
                        
   0741   de 28         il_samesize:   ldx     basic_lineno ; now there is space at position for the new line
                                                            ; check lineno:  is 0 if delete
   0743   27 19                        beq     il_done      ; nothing to copy (gap is already closed)
   0745   de bc                        ldx     IL_temp      ; start of area to insert into (the gap)
   0747   96 28                        ldaa    basic_lineno ; store the line number into this area
   0749   d6 29                        ldab    basic_lineno+1
   074b   a7 00                        staa    0,x
   074d   08                           inx
   074e   e7 00                        stab    0,x
                        
   0750   08            il_moveline:   inx
   0751   df bc                        stx     IL_temp      ; position of gap
   0753   bd 03 18                     jsr     fetch_basicchar ; get char from input buffer
   0756   de bc                        ldx     IL_temp      ; put it into gap
   0758   a7 00                        staa    0,x
   075a   81 0d                        cmpa    #$D          ; until EOLN
   075c   26 f2                        bne     il_moveline
                        
   075e   9e 26         il_done:       lds     top_of_stack ; finished with IL
                                                            ; reload stack pointer
   0760   7e 02 22                     jmp     restart_il_nocr ; and re-enter BASIC loop
                        
                        ;------------------------------------------------------------------------------
                        ; Break routine for Motorola MIkBUG
                        ;------------------------------------------------------------------------------
   0763   b6 fc 18      minibug_chkbreak: ldaa ACIACS        ; ACIA control status
   0766   47                           asra                 ; check bit0: receive buffer full
   0767   24 06                        bcc     locret_776   ; no, exit, carry clear
   0769   b6 fc 19                     ldaa    ACIADA        ; load ACIA data
   076c   26 01                        bne     locret_776   ; if not NUL, return carry set
   076e   0c                           clc                  ; was NUL, ignore, retun carry clear
                        
   076f   39            locret_776:    rts
                        
                        ;------------------------------------------------------------------------------
                        ; Input/Echo routine for Motorola MINIBUG
                        ;------------------------------------------------------------------------------
   0770   b6 fc 18      minibug_inoutput: ldaa ACIACS        ; get ACIA status
   0773   47                           asra                 ; check bit: receiver buffer empty?
   0774   24 fa                        bcc     minibug_inoutput ; yes, wait for char
   0776   b6 fc 19                     ldaa    ACIADA        ; get ACIA data
   0779   36                           psha                 ; save it for later
                        
   077a   b6 07 70      wait_tdre:     ldaa    minibug_inoutput        ; get ACIA status
   077d   84 02                        anda    #2           ; check bit1: transmit buf empty?
   077f   27 f9                        beq     wait_tdre    ; no, wait until transmitted
   0781   32                           pula                 ; restore char
   0782   b7 fc 19                     staa    ACIADA        ; echo data just entered
   0785   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; test break routine for MIKBUG
                        ;------------------------------------------------------------------------------
   0786   b6 80 04      mikbug_chkbreak: ldaa    $8004      ; check bitbang input of PIA
   0789   0c                           clc
   078a   2b 0d                        bmi     locret_7A0   ; if 1, exit: no input
                        
   078c   b6 80 04      loc_793:       ldaa    $8004        ; is zero, wait until 1
   078f   2a fb                        bpl     loc_793
   0791   8d 00                        bsr     *+2          ; emit byte 0xFF twice
   0793   86 ff                        ldaa    #$FF         ; emit 0xFF
   0795   bd 01 09                     jsr     OUT_V
   0798   0d                           sec
                        
   0799   39            locret_7A0:    rts
                        
                        ;******************************************************************************
                        ; The IL interpreter commented
                        ;******************************************************************************
   079a   24 3a 91      start_of_il:   fcb $24,':',$11+$80  ; PL    : print literal ":",XON
   079d   27                           fcb $27              ; GL    : get input line
   079e   10                           fcb $10              ; SB    : save BASIC pointer
   079f   e1                           fcb $E1              ; BE  01: if not eoln, branch to il_test_insert
   07a0   59                           fcb $59              ; BR  19: branch to start_of_il
   07a1   c5            il_test_insert: fcb $C5             ; BN  05: if not number, branch to il_test_let
   07a2   2a                           fcb $2A              ; IL    : insert BASIC line
   07a3   56                           fcb $56              ; BR  16: branch to start_of_il
   07a4   10            il_run:        fcb $10              ; SB    : save BASIC pointer
   07a5   11                           fcb $11              ; RB    : restore BASIC pointer
   07a6   2c                           fcb $2C              ; XC    : execute
   07a7   8b 4c 45 d4   il_test_let:   fcb $8B,'L','E',$D4  ; BC  0B: if not "LET", branch to il_test_go
   07ab   a0                           fcb $A0              ; BV  00: if not variable, error
   07ac   80 bd                        fcb $80,'='+$80      ; BC  00: if not "=", error
   07ae   30 bc         il_let:        fcb $30,$BC          ; JS 0BC: call il_expr
   07b0   e0                           fcb $E0              ; BE  00: if not eoln, error
   07b1   13                           fcb $13              ; SV    : store variable
   07b2   1d                           fcb $1D              ; NX    : next BASIC statement
   07b3   94 47 cf      il_test_go:    fcb $94,'G','O'+$80  ; BC  14: if not "GO", branch to il_test_10
   07b6   88 54 cf                     fcb $88,'T','O'+$80  ; BC  08: if not "TO", branch to il_test_sub
   07b9   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   07bb   e0                           fcb $E0              ; BE  00: if not eoln, error
   07bc   10                           fcb $10              ; SB    : save BASIC pointer
   07bd   11                           fcb $11              ; RB    : restore BASIC pointer
   07be   16                           fcb $16              ; GO    : GOTO
   07bf   80 53 55 c2   il_test_sub:   fcb $80,'S','U','B'+$80
                                                            ; BC  00: if not "SUB", error
   07c3   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   07c5   e0                           fcb $E0              ; BE  00: if not eoln, error
   07c6   14                           fcb $14              ; GS    : GOSUB save
   07c7   16                           fcb $16              ; GO    : GOTO
   07c8   90 50 d2      il_test_pr:    fcb $90,'P','R'+$80  ; BC  10: if not "PR", branch to il_jump1
   07cb   83 49 4e d4                  fcb $83,'I','N','T'+$80 
                                                            ; BC  03: if not "INT", branch to il_print
   07cf   e5            il_print:      fcb $E5              ; BE  05: if not eoln, branch to il_pr_test_dq
   07d0   71                           fcb $71              ; BR  31: branch to il_pr_must_eoln
   07d1   88 bb         il_pr_test_semi: fcb $88,';'+$80    ; BC  08: if not ";", branch to il_pr_test_com
   07d3   e1            il_pr_eoln:    fcb $E1              ; BE  01: if not eoln, branch to il_pr_test_dq
   07d4   1d                           fcb $1D              ; NX    : next BASIC statement
   07d5   8f a2         il_pr_test_dq: fcb $8F,'"'+$80      ; BC  0F: if not dblquote, branch to il_pr_expr
   07d7   21                           fcb $21              ; PQ    : print    BASIC string
   07d8   58                           fcb $58              ; BR  18: branch to il_test_semi
   07d9   6f            il_jump1:      fcb $6F              ; BR  2F: branch to il_test_if
   07da   83 ac         il_pr_test_com: fcb $83,','+$80     ; BC  03: if not ",", branch to il_test_colon
   07dc   22                           fcb $22              ; PT    : print TAB
   07dd   55                           fcb $55              ; BR  15: branch to il_pr_eoln
   07de   83 ba         il_test_colon: fcb $83,':'+$80      ; BC  03: if not ":", branch to il_pr_must_eoln
   07e0   24 93                        fcb $24,$13+$80      ; PR    : print literal XOFF
   07e2   e0            il_pr_must_eoln: fcb $E0            ; BE  00: if not eoln, error
   07e3   23                           fcb $23              ; NL    : new line
   07e4   1d                           fcb $1D              ; NX    : next statement
   07e5   30 bc         il_pr_expr:    fcb $30,$BC          ; JS 0BC: call il_expr
   07e7   20                           fcb $20              ; PN    : print number
   07e8   48                           fcb $48              ; BR  08: branch to il_pr_test_semi
   07e9   91 49 c6                     fcb $91,'I','F'+$80  ; BC  11: if not "IF", branch to il_test_input
   07ec   30 bc         il_test_if:    fcb $30,$BC          ; JS 0BC: call il_expr
   07ee   31 34                        fcb $31,$34          ; JS 134: call il_cmpop
   07f0   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   07f2   84 54 48 45                  fcb $84,'T','H','E','N'+$80
   07f6   ce            
                                                            ; BC  04: if not "THEN", branch to il_test_input
   07f7   1c                           fcb $1C              ; CP    : compare
   07f8   1d                           fcb $1D              ; NX    : next BASIC statement
   07f9   38 0d                        fcb $38,$D           ; J  00D: jump il_test_let
   07fb   9a 49 4e 50   il_test_input: fcb $9A,'I','N','P','U','T'+$80
   07ff   55 d4         
                                                            ; BC  1A: if not "INPUT", branch to il_test_return
   0801   a0            il_in_more:    fcb $A0              ; BV  00: if not variable, error
   0802   10                           fcb $10              ; SB    : save BASIC pointer
   0803   e7                           fcb $E7              ; BE  07: if not eoln, branch to il_in_test_com
   0804   24 3f 20 91   il_in_query:   fcb $24,'?',' ',$11+$80
                                                            ; PR    : print literal "? ",XON
   0808   27                           fcb $27              ; GL    : get input line
   0809   e1                           fcb $E1              ; BE  01: if not eoln, branch to il_in_test_com
   080a   59                           fcb $59              ; BR  19: branch to il_in_query
   080b   81 ac         il_in_test_com: fcb $81,','+$80     ; BC  01: if not ",", branch to il_in_get
   080d   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   080f   13                           fcb $13              ; SV    : store variable
   0810   11                           fcb $11              ; RB    : restore BASIC pointer
   0811   82 ac                        fcb $82,','+$80      ; BC  02: if not ",", branch il_in_done
   0813   4d                           fcb $4D              ; BR  0D: branch to il_in_more
   0814   e0                           fcb $E0              ; BE  00: if not eoln, error
   0815   1d                           fcb $1D              ; NX    : next BASIC statement
   0816   89 52 45 54   il_test_return: fcb $89,'R','E','T','U','R','N'+$80
   081a   55 52 ce      
                                                            ; BC  09: if not "RETURN", branch to il_test_end
   081d   e0                           fcb $E0              ; BE  00: if not eoln, error
   081e   15                           fcb $15              ; RS    : restore saved line
   081f   1d                           fcb $1D              ; NX    : next BASIC statement
   0820   85 45 4e c4   il_test_end:   fcb $85,'E','N','D'+$80
                                                            ; BC  05: if not "END", branch to il_test_list
   0824   e0                           fcb $E0              ; BE  00: if not eoln, error
   0825   2d                           fcb $2D              ; WS    : stop
   0826   98 4c 49 53   il_test_list:  fcb $98,'L','I','S','T'+$80
   082a   d4            
                                                            ; BC  18: if not "LIST", branch to il_test_run
   082b   ec                           fcb $EC              ; BE  0C: if not eoln, branch to il_li_line
   082c   24 00 00 00   il_li_newline: fcb $24,0,0,0,0,$0A,0+$80
   0830   00 0a 80      
                                                            ; PR    : print literal NUL,NUL,NUL,NUL,LF,NUL
   0833   1f                           fcb $1F              ; LS    : list the program
   0834   24 93                        fcb $24,$13+$80      ; PR    : print literal XOFF
   0836   23                           fcb $23              ; NL    : newline
   0837   1d                           fcb $1D              ; NX    : next BASIC statement
   0838   30 bc         il_li_line:    fcb $30,$BC          ; JS 0BC: call il_expr
   083a   e1                           fcb $E1              ; if not eoln, branch to il_li2
   083b   50                           fcb $50              ; BR  10: branch to il_li_newline
   083c   80 ac                        fcb $80,','+$80      ; BC  00: if not ",", error
   083e   59                           fcb $59              ; BR  19: branch to il_li_line
   083f   85 52 55 ce   il_test_run:   fcb $85,'R','U','N'+$80
                                                            ; BC  05: if not "RUN", branch to il_test_clear
   0843   38 0a                        fcb $38,$0A          ; J  00A: branch to il_run
   0845   86 43 4c 45   il_test_clear: fcb $86,'C','L','E','A','R'+$80
   0849   41 d2         
                                                            ; BC  06: if not "CLEAR", branch to il_test_rem
   084b   2b                           fcb $2B              ; MT   : mark basic program space empty
   084c   84 52 45 cd   il_test_rem:   fcb $84,'R','E','M'+$80
                                                            ; BC  04: if not "REM, branch to il_assign
   0850   1d                           fcb $1D              ; NX    : next BASIC statement
   0851   a0                           fcb $A0              ; BV  00: if not variable, error
   0852   80 bd         il_assign:     fcb $80,'='+$80      ; BC  00: if not "=", error
   0854   38 14                        fcb $38,$14          ; J  014: branch to il_let
   0856   85 ad         il_expr:       fcb $85,'-'+$80      ; if not "-", branch to il_expr_plus
   0858   30 d3                        fcb $30,$D3          ; JS 0D3: call il_term
   085a   17                           fcb $17              ; NE    : negate
   085b   64                           fcb $64              ; BR  24: branch to il_expr1
   085c   81 ab         il_expr_plus:  fcb $81,'+'+$80      ; BC  01: if not "+", branch to il_expr0
   085e   30 d3         il_expr0:      fcb $30,$D3          ; JS 0D3: call il_term
   0860   85 ab         il_expr1:      fcb $85,'+'+$80      ; BC  05: if not "+", branch to il_expr2
   0862   30 d3                        fcb $30,$D3          ; JS 0D3: call il_term
   0864   18                           fcb $18              ; AD    : add
   0865   5a                           fcb $5A              ; BR  1A: branch to il_expr1
   0866   85 ad         il_expr2:      fcb $85,'-'+$80      ; BC  05: if not "-", branch to il_term
   0868   30 d3                        fcb $30,$D3          ; JS 0D3: call il_term
   086a   19                           fcb $19              ; SU    : subtract
   086b   54                           fcb $54              ; BR  14: branch to il_expr1
   086c   2f            il_expr3:      fcb $2F              ; RT    : return
   086d   30 e2         il_term:       fcb $30,$E2          ; JS 0E2: call il_fact
   086f   85 aa         il_term0:      fcb $85,'*'+$80      ; BC 05: if not "*", branch to il_term1
   0871   30 e2                        fcb $30,$E2          ; JS 0E2: call il_factor
   0873   1a                           fcb $1A              ; MP    : multiply
   0874   5a                           fcb $5A              ; BR  1A: branch to il_term0
   0875   85 af         il_term1:      fcb $85,'/'+$80      ; if not "/", branch to il_term2
   0877   30 e2                        fcb $30,$E2          ; JS 0E2: call il_factor
   0879   1b                           fcb $1B              ; DV    : divide
   087a   54                           fcb $54              ; BR  14: branch to il_term0
   087b   2f            il_term2:      fcb $2F              ; RT    : return
   087c   98 52 4e c4   il_factor:     fcb $98,'R','N','D'+$80
                                                            ; BC  18: if not RND, branch to il_factor1
   0880   0a 80 80                     fcb  $A,$80,$80      ; LN    : push literal 0x8080
   0883   12                           fcb $12              ; FV    : fetch variable rnd_seed
   0884   0a 09 29                     fcb  $A,$09,$29      ; LN    : push literal 0x0929
   0887   1a                           fcb $1A              ; MP    : multiply
   0888   0a 1a 85                     fcb  $A,$1A,$85      ; LN    : push literal 0x1A85
   088b   18                           fcb $18              ; AD    : add
   088c   13                           fcb $13              ; SV    : store variable rnd_seed
   088d   09 80                        fcb   9,$80          ; LB    : push literal byte 0x80
   088f   12                           fcb $12              ; FV    : fetch variable rnd_seed
   0890   01                           fcb   1              ; SX  01: stack    exchange
   0891   0b                           fcb  $B              ; DS    : duplicate stack top
   0892   31 30                        fcb $31,$30          ; JS 130: call il_rn_paren
   0894   61                           fcb $61              ; BR  21: branch to il_factor2
   0895   72            il_factor1:    fcb $72              ; BR  32: branch to il_usr
   0896   0b            il_factor2:    fcb  $B              ; DS    : duplicate stack top
   0897   04                           fcb   4              ; SX  04: stack    exchange
   0898   02                           fcb   2              ; SX  02: stack    exchange
   0899   03                           fcb   3              ; SX  03: stack    exchange
   089a   05                           fcb   5              ; SX  05: stack    exchange
   089b   03                           fcb   3              ; SX  03: stack    exchange
   089c   1b                           fcb $1B              ; DV    : divide
   089d   1a                           fcb $1A              ; MP    : multiply
   089e   19                           fcb $19              ; SU    : subtract
   089f   0b                           fcb  $B              ; DS    : duplicate stack top
   08a0   09 06                        fcb   9,$06          ; LB    : push literal byte 0x06
   08a2   0a 00 00                     fcb  $A,$00,$00      ; LN    : push literal number 0x0000
   08a5   1c                           fcb $1C              ; CP    : compare
   08a6   17                           fcb $17              ; NE    : negate
   08a7   2f                           fcb $2F              ; RT    : return
   08a8   8f 55 53 d2   il_usr:        fcb $8F,'U','S','R'+$80
                                                            ; BC  0F: if not "USR", branch to il_factor3
   08ac   80                           fcb $80              ; BC  00: if not "(", error
   08ad   a8                           fcb $A8              ; if not variable, branch to il_usr1
   08ae   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   08b0   31 2a                        fcb $31,$2A          ; JS 12A: call il_us_test_com
   08b2   31 2a                        fcb $31,$2A          ; JS 12A: call il_us_test_com
   08b4   80 a9                        fcb $80,')'+$80      ; BC  00: if not ")", error
   08b6   2e            il_usr1:       fcb $2E              ; US    : machine language call
   08b7   2f                           fcb $2F              ; RT    : return
   08b8   a2            il_factor3:    fcb $A2              ; BV  02: if not variable, branch to il_factor4
   08b9   12                           fcb $12              ; FV    : fetch    variable
   08ba   2f                           fcb $2F              ; RT    : return
   08bb   c1            il_factor4:    fcb $C1              ; BN  01: if not number, branch    to il_lparen
   08bc   2f                           fcb $2F              ; RT    : return
   08bd   80 a8                        fcb $80,'('+$80      ; BC  00: if not "(", error
   08bf   30 bc         il_factor5:    fcb $30,$BC          ; JS 0BC: call il_expr
   08c1   80 a9                        fcb $80,')'+$80      ; BC  00: if not ")", error
   08c3   2f                           fcb $2F              ; RT    : return
   08c4   83 ac         il_us_test_com: fcb $83,','+$80     ; BC  03: if not ",", branch to il_us_dup
   08c6   38 bc                        fcb $38,$BC          ; J  0BC: branch to il_expr
   08c8   0b            il_us_dup:     fcb  $B              ; DS    : duplicate stack top
   08c9   2f                           fcb $2F              ; RT    : return
   08ca   80 a8         il_rn_paren:   fcb $80,'('+$80      ; BC  00: if not "(", error
   08cc   52                           fcb $52              ; BR  12: branch to il_factor5
   08cd   2f                           fcb $2F              ; RT    : return
   08ce   84 bd         il_cmpop:      fcb $84,'='+$80      ; if not "=", branch to il_cmpop1
   08d0   09 02                        fcb   9,$02          ; LB    : push literal byte 0x02
   08d2   2f                           fcb $2F              ; RT    ; return
   08d3   8e bc         il_cmpop1:     fcb $8E,'<'+$80      ; BR  0E: if not "<", branch to il_cmpop4
   08d5   84 bd                        fcb $84,'='+$80      ; BR  04: if not "=", branch to il_cmpop2
   08d7   09 93                        fcb   9,$93          ; LB    : push literal byte 0x93
   08d9   2f                           fcb $2F              ; RT    : return
   08da   84 be         il_cmpop2:     fcb $84,'>'+$80      ; BR  04: if not ">", branch to il_cmpop3
   08dc   09 05                        fcb   9,$05          ; LB    : push literal byte 0x05
   08de   2f                           fcb $2F              ; RT    : return
   08df   09 91         il_cmpop3:     fcb   9,$91          ; LB    : push literal byte 0x91
   08e1   2f                           fcb $2F              ; RT    : return
   08e2   80 be         il_cmpop4:     fcb $80,'>'+$80      ; BR  00: if not ">", error
   08e4   84 bd                        fcb $84,'='+$80      ; BR  04: if not "=", branch to il_cmpop5
   08e6   09 06                        fcb   9,$06          ; LB    : push literal byte 0x06
   08e8   2f                           fcb $2F              ; RT    : return
   08e9   84 bc         il_cmpop5:     fcb $84,'<'+$80      ; BR  04: if not "<", branch to il_cmpop6
   08eb   09 95                        fcb   9,$95          ; LB    : push literal byte 0x95
   08ed   2f                           fcb $2F              ; RT    : return
   08ee   09 04         il_cmpop6:     fcb   9,$04          ; LB    : push literal byte 0x04
   08f0   2f                           fcb $2F              ; RT   :return
   08f1   00                           fcb 0
   08f2   00                           fcb 0
                        
                        ;------------------------------------------------------------------------------
                        ; not called: reference code for break check for MIKBUG/MINIBUG monitors
                        ;------------------------------------------------------------------------------
   08f3   7e 07 63                     jmp     minibug_chkbreak
   08f6   7e 07 86                     jmp     mikbug_chkbreak
                        
   08f9                 		       end
fc18  ACIACS        fc19  ACIADA        00b8  BP_save       010f  BSC       
010c  BV            0200  COLD_S        0100  CV            03c7  IL_AD     
0290  IL_BBR        02e6  IL_BC         0303  IL_BE         0333  IL_BN     
030a  IL_BV         041b  IL_CP         0189  IL_DS         0363  IL_DV     
0293  IL_FBR        03f8  IL_FV         0652  IL_GL         0486  IL_GO     
04c6  IL_GS         06aa  IL_IL         01d7  IL_LB         01db  IL_LN     
05cf  IL_LS         03dd  IL_MP         020a  IL_MT         03ba  IL_NE     
0620  IL_NL         01fc  IL_NO         0441  IL_NX         05a5  IL_PC     
053d  IL_PN         05b2  IL_PQ         05ba  IL_PT         04a8  IL_RB     
0491  IL_RS         049e  IL_RT         04a3  IL_SB         01a6  IL_SP     
03c5  IL_SU         0408  IL_SV         01b9  IL_US         0476  IL_XQ     
01fe  IL_baseaddr    00bc  IL_temp       f1f3  INEEE         0106  IN_V      
0110  LSC           00b6  LS_end        f20a  OUTEEE        0109  OUT_V     
0111  PCC           0113  SSS           0112  TMC           021d  WARM_S    
0103  WV            00ba  X_save        0028  basic_lineno    002c  basic_ptr 
002e  basicptr_save    02f6  bc_lastchar    02ea  bc_loop       02fd  bc_nomatch
00bf  column_cnt    0438  cp_is_eq      0436  cp_is_gt      043a  cp_is_lt  
0624  crlf          02e2  displ_error    045a  do_break      0482  do_runmode
064d  do_xoff       0648  do_xon        038c  dv_loop       03a6  dv_shift  
03a3  dv_smaller    0590  emit_char     0642  emit_char_at_0    0582  emit_digit
058b  emit_digit1    0579  emit_digits    063b  emit_nul_padding    053a  emit_number
0024  end_prgm      0022  end_ram       028b  err_at        0254  error     
0282  error_no_lineno    023e  exec_il_opcode    03d8  expr_check_4bytes    03da  expr_check_nbytes
01a9  expr_pop_byte    0196  expr_push_a    0194  expr_push_byte    018d  expr_push_word
03d1  expr_save_pop    0030  expr_stack    00c1  expr_stack_low    00c3  expr_stack_top
00c2  expr_stack_x    0318  fetch_basicchar    01f5  fetch_il_op    0205  find_end_ram
0530  find_eoln     0537  find_exit     0512  find_line     051d  find_line1
0322  get_nchar     04f4  get_payload    068b  gl_chkend     0684  gl_ctrlx  
0699  gl_dobackspace    065c  gl_loop       0695  gl_savechar    048b  go_error  
044e  go_found_line    0504  gp_loop       029d  handle_30_ff    02c4  handle_40_ff
01e4  handle_il_SX    0852  il_assign     08ce  il_cmpop      08d3  il_cmpop1 
08da  il_cmpop2     08df  il_cmpop3     08e2  il_cmpop4     08e9  il_cmpop5 
08ee  il_cmpop6     0727  il_dogrow     075e  il_done       0856  il_expr   
085e  il_expr0      0860  il_expr1      0866  il_expr2      086c  il_expr3  
085c  il_expr_plus    087c  il_factor     0895  il_factor1    0896  il_factor2
08b8  il_factor3    08bb  il_factor4    08bf  il_factor5    06c3  il_findeoln
0298  il_goto       072b  il_grow       0711  il_growline    0801  il_in_more
0804  il_in_query    080b  il_in_test_com    07d9  il_jump1      011b  il_jumptable
07ae  il_let        0838  il_li_line    082c  il_li_newline    06c9  il_linenotfound
0233  il_mainloop    0750  il_moveline    002a  il_pc         00c4  il_pc_save
07d3  il_pr_eoln    07e5  il_pr_expr    07e2  il_pr_must_eoln    07da  il_pr_test_com
07d5  il_pr_test_dq    07d1  il_pr_test_semi    07cf  il_print      08ca  il_rn_paren
0231  il_rs_return    0239  il_rs_target    07a4  il_run        0741  il_samesize
06f9  il_shrink     086d  il_term       086f  il_term0      0875  il_term1  
087b  il_term2      0845  il_test_clear    07de  il_test_colon    0820  il_test_end
07b3  il_test_go    07ec  il_test_if    07fb  il_test_input    07a1  il_test_insert
07a7  il_test_let    0826  il_test_list    07c8  il_test_pr    084c  il_test_rem
0816  il_test_return    083f  il_test_run    07bf  il_test_sub    08c8  il_us_dup 
08c4  il_us_test_com    08a8  il_usr        08b6  il_usr1       045f  j1_error  
04f1  j2_error      0301  j_FBR         0418  j_IL_SP       0645  j_emitchar
01a3  j_error       03d5  j_expr_pop_byte    0581  last_digit    00be  lead_zero 
0381  loc_389       0462  loc_46A       04ab  loc_4B3       04c3  loc_4CB   
054a  loc_552       059f  loc_5A7       062e  loc_636       0637  loc_63E   
064e  loc_655       06db  loc_6E2       06e5  loc_6EC       073d  loc_744   
078c  loc_793       0332  locret_33A    03c4  locret_3CC    0459  locret_461
0511  locret_519    05a2  locret_5AA    061a  locret_622    076f  locret_776
0799  locret_7A0    0558  loop_10000s    0560  loop_1000s    0568  loop_100s 
0570  loop_10s      033c  loop_bn       05ac  loop_pq       061b  ls_exit   
0607  ls_getlineno    05f7  ls_loop       05df  ls_nostart    0614  ls_to_linestart
0786  mikbug_chkbreak    0763  minibug_chkbreak    0770  minibug_inoutput    03e5  mp_loop   
03f1  mp_notadd     03c2  ne_nocarry    03bc  negate        02da  not_bbr   
0445  nx_loop       05a3  pc_loop       0114  peek          0118  poke      
01ab  pop_byte      05c6  pt_loop       05c3  pt_print_spc    04cf  push_payload
021f  restart_il    0222  restart_il_nocr    0080  rnd_seed      00c0  run_mode  
0469  save_lineno    079a  start_of_il    0020  start_prgm    0177  sub_177   
0180  sub_180       04b9  swap_bp       0521  test_line     0026  top_of_stack
01cd  us_copyargs    01c0  us_do         0082  var_tbl       077a  wait_tdre 
